'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ticTacToe = require('./ticTacToeGame');

var msgs = ticTacToe.messages;

var player1 = msgs.players.player1;
var player2 = msgs.players.player2;
var player1PlacedToken = msgs.placeToken.player1PlacedToken;
var player2PlacedToken = msgs.placeToken.player2PlacedToken;
var alreadyUsed = msgs.placeTokenError.alreadyUsed;
var outOfBounds = msgs.placeTokenError.outOfBounds;
var stalemate = msgs.winMessages.stalemate;
var horizontal = msgs.winMessages.matchMessages.horizontalMatch;
var vertical = msgs.winMessages.matchMessages.verticalMatch;
var diagonal = msgs.winMessages.matchMessages.diagonalMatch;

var token1 = {
    player: 'Bill',
    avater: './bill.png'
};
var token2 = {
    player: 'Jessie',
    avatar: './jessie.png'
};

test('new game starts properly', function () {
    var game = ticTacToe.newTicTacToeGame(token1, token2);
    expect(game.getCurrentTurn()).toBe(player1);
    //game generates messages for placing tokens
    var message = game.placeToken(0, 0);
    expect(message).toBe(player1PlacedToken);
    message = game.placeToken(0, 2);
    expect(message).toBe(player2PlacedToken);
    message = game.placeToken(1, 1);
    expect(message).toBe(player1PlacedToken);
    //game does not allow placing a token on a taken space
    message = game.placeToken(0, 0);
    expect(message).toBe(alreadyUsed);
    //game does not allow an out of bounds move
    message = game.placeToken(0, 5);
    expect(message).toBe(outOfBounds);
});

test('game ends when a player wins or when there are no moves left to play', function () {
    var game = ticTacToe.newTicTacToeGame(token1, token2);
    game.placeToken(0, 0);
    game.placeToken(2, 0);
    game.placeToken(1, 1);
    var message = game.placeToken(2, 1);
    //win message doesn't appear before a winning condition
    expect(message).toBe(player2PlacedToken);
    message = game.placeToken(2, 2);
    //win message appears on a winning condition
    var expectedWinMessage = [_defineProperty({
        matchType: diagonal.matchType,
        value: token1
    }, diagonal.locationIdentifierKey, diagonal.locations.topLeft)];
    expect(message).toEqual(expectedWinMessage);
    var gameState = game.getCurrentGameState();
    game.placeToken(0, 2);
    var nextGameState = game.getCurrentGameState();
    //additional moves do not get placed
    expect(gameState).toEqual(nextGameState);
    //stalemate games return stalemate message
    game = ticTacToe.newTicTacToeGame('X', 'Y');
    game.placeToken(0, 0);
    game.placeToken(2, 0);
    game.placeToken(1, 1);
    game.placeToken(2, 2);
    game.placeToken(2, 1);
    game.placeToken(0, 1);
    game.placeToken(1, 2);
    game.placeToken(1, 0);
    message = game.placeToken(0, 2);
    var expectedGameState = [['X', 'Y', 'Y'], ['Y', 'X', 'X'], ['X', 'X', 'Y']];
    gameState = game.getCurrentGameState();
    expect(gameState).toEqual(expectedGameState);
    expect(message).toBe(stalemate);
});

test('isValidMoveMessage only returns true for messages generated by playing valid moves', function () {
    var game = ticTacToe.newTicTacToeGame(token1, token2);
    var message = game.placeToken(0, 0);
    //returns true for valid placements
    expect(game.isAValidMoveMessage(message)).toBe(true);
    message = game.placeToken(0, 1);
    expect(game.isAValidMoveMessage(message)).toBe(true);
    //returns false for invalid placements
    message = game.placeToken(0, 0);
    expect(game.isAValidMoveMessage(message)).toBe(false);
    message = game.placeToken(0, 5);
    expect(game.isAValidMoveMessage(message)).toBe(false);
    //returns true for winner
    game.placeToken(1, 1);
    game.placeToken(2, 0);
    message = game.placeToken(2, 2);
    expect(message).toEqual([{
        matchType: 'diagonal match',
        value: token1,
        startCorner: 'top left'
    }]);
    expect(game.isAValidMoveMessage(message)).toBe(true);
    //returns true for stalemate
    game = ticTacToe.newTicTacToeGame('X', 'Y');
    game.placeToken(0, 0);
    game.placeToken(2, 0);
    game.placeToken(1, 1);
    game.placeToken(2, 2);
    game.placeToken(2, 1);
    game.placeToken(0, 1);
    game.placeToken(1, 2);
    game.placeToken(1, 0);
    message = game.placeToken(0, 2);
    expect(message).toBe(stalemate);
    expect(game.isAValidMoveMessage(message)).toBe(true);
});